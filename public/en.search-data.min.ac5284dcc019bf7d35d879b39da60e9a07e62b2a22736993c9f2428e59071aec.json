[{"id":0,"href":"/post/reverse_proxy/","title":"Logging client to server network traffic","section":"Posts","content":" While developing applications it is quite common that the application that you are developing needs to talk to other services over http(s). More often than not, you may want to see the data that is being sent from your application to other. This scenario may also occur when you have inherited/installed an application and would like to understand the client server request and response data.\nBased on your development language, it might be possible to enable logging in verbose level and find out this detail. While this might work, it may always not be possible.\nFor example you have inherited an application and that application does not offer logging capability.\nnetcat comes in handy to set up quick reverse proxy and monitor the network traffic that is going from client application to the server application. Advantage is that you can use netcat with any program as long as you can configure the server endpoint.\nOn Mac OS you can install ncat with a simple command\nbrew install nmap Once netcat is installed, you can start http reverse proxy as\nmkfifo pipe ncat -kl 8001 \u0026lt; pipe | tee -a traffic | ncat httpbin.org 80 | tee -a traffic \u0026gt; pipe Now any traffic that you send on your localhost port 8001 will be redirected to httpbin.org on port 80. All the details of http request and response are logged into the file traffic.\nYou can verify this behavior with the following command while ncat is running by issuing the following command and looking at the contents in the file traffic.\ncurl -X GET \u0026#34;http://localhost:8001/get\u0026#34; -H \u0026#34;accept: application/json\u0026#34; At this point of time, it is https everywhere and netcat got you covered in that scenario too. All you need to do is add a flag and issue the command as below\nncat -kl 8001 \u0026lt; pipe | tee -a traffic | ncat --ssl httpbin.org 443 | tee -a traffic \u0026gt; pipe now your traffic will be forwarded to https version.\n"},{"id":1,"href":"/post/dotfiles/","title":"Dotfiles management with gnu stow","section":"Posts","content":" I used to manage my dotfiles in a git repository and add symbolic links manually. Today I stumbled upon a program called stow to manage dotfiles and thought I will give it a go.\nI wont go into details of my previous workflow but focus on how to use gnu stow.\nLet us walk through an example of using stow for neovim dotfiles.\nCreate a git repository to hold dotfiles\nmkdir -p ~/go/src/github.com/me/dotfiles Create directory for neovim\nmkdir -p ~/go/src/github.com/me/dotfiles/neovim/.config/nvim Go ahead and create your configuration files\nFor starter, you init.vim file will be placed under touch ~/go/src/github.com/me/dotfiles/neovim/.config/nvim/init.vim\u0026#39; Once you have the configuration files, you can execute\nstow -t ~ ~/go/src/github.com/me/dotfiles/neovim Above command will create link to configuration folder\n~/.config/nvim stow basically creates a symbolic link for the folders that are present under your specified directory ( ~/go/src/github.com/me/dotfiles/neovim) in the target directory (~)\n"},{"id":2,"href":"/post/neovim_go/","title":"Go development setup with Neovim","section":"Posts","content":" Before I start writing this post, I have a confession to make. I never thought I would be writing a post about an editor and itâ€™s configuration, yet here I am writing about one of the most renowned editors, neovim. There are numerous posts about neovim and its configuration out there, but there is always scope for one more blog post.\nThe goal of this post is to setup neovim for go development quickly; I won\u0026#39;t go into detailing about each plugin and custom mappings.\nThough there is packer for managing packages in neovim, I stick with vim-plug for plugin management\nSteps Create configuration files with the following commands:\ntouch ~/.config/nvim/init.vim touch ~/.config/nvim/mappings.vim touch ~/.config/nvim/plugins.vim touch ~/.config/nvim/nerdtree.vim mkdir -p lua/config touch ~/.config/nvim/lua/config/telescope.lua touch ~/.config/nvim/lua/config/golsp.lua Contents of ~/.config/nvim/init.vim\nsource ~/.config/nvim/plugins.vim source ~/.config/nvim/mappings.vim source ~/.config/nvim/nerdtree.vim :lua require(\u0026#39;config/telescope\u0026#39;) :lua require(\u0026#39;config/golsp\u0026#39;) Contents of ~/.config/nvim/plugins.vim\ncall plug#begin(\u0026#39;~/.config/nvim/plugged\u0026#39;) Plug \u0026#39;scrooloose/nerdtree\u0026#39; Plug \u0026#39;junegunn/fzf\u0026#39;, { \u0026#39;do\u0026#39;: { -\u0026gt; fzf#install() } } Plug \u0026#39;junegunn/fzf.vim\u0026#39; Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;tpope/vim-fugitive\u0026#39; Plug \u0026#39;airblade/vim-gitgutter\u0026#39; Plug \u0026#39;chriskempson/base16-vim\u0026#39; Plug \u0026#39;nvim-lua/popup.nvim\u0026#39; Plug \u0026#39;nvim-lua/plenary.nvim\u0026#39; Plug \u0026#39;nvim-telescope/telescope.nvim\u0026#39; Plug \u0026#39;neovim/nvim-lspconfig\u0026#39; Plug \u0026#39;nvim-treesitter/nvim-treesitter\u0026#39;, {\u0026#39;do\u0026#39;: \u0026#39;:TSUpdate\u0026#39;} Plug \u0026#39;simrat39/symbols-outline.nvim\u0026#39; Plug \u0026#39;ray-x/lsp_signature.nvim\u0026#39; Plug \u0026#39;ms-jpq/coq_nvim\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;coq\u0026#39;} Plug \u0026#39;ms-jpq/coq.artifacts\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;artifacts\u0026#39;} call plug#end() Contents of ~/.config/nvim/mappings.vim let mapleader=\u0026#34;\\\u0026lt;space\u0026gt;\u0026#34; set nu rnu set tabstop=2 softtabstop=0 expandtab shiftwidth=2 smarttab map \u0026lt;C-s\u0026gt; :w\u0026lt;CR\u0026gt; imap \u0026lt;C-s\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;i let g:coq_settings = { \u0026#39;auto_start\u0026#39;: v:true } :lua vim.o.completeopt = \u0026#39;menuone,noselect\u0026#39; autocmd BufWritePre *.go lua gofmt(1000) Contents of ~/.config/nvim/nerdtree.vim nnoremap \u0026lt;C-n\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; let g:NERDTreeWinPos = \u0026#34;right\u0026#34; Contents of ~/.config/nvim/lua/config/telescope.lua require\u0026#39;telescope\u0026#39;.setup { preview_cutoff = 5 } local opts = {} -- See `:help vim.lsp.*` for documentation on any of the below functions local keymap = vim.api.nvim_set_keymap keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;ff\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua require(\u0026#34;telescope.builtin\u0026#34;).find_files()\u0026lt;cr\u0026gt;\u0026#39;, opts) keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;fg\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua require(\u0026#34;telescope.builtin\u0026#34;).live_grep()\u0026lt;cr\u0026gt;\u0026#39;, opts) keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;fb\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua require(\u0026#34;telescope.builtin\u0026#34;).buffers()\u0026lt;cr\u0026gt;\u0026#39;, opts) keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;fh\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua require(\u0026#34;telescope.builtin\u0026#34;).help_tags()\u0026lt;cr\u0026gt;\u0026#39;, opts) Contents of ~/.config/nvim/lua/config/golsp.lua local nvim_lsp = require \u0026#39;lspconfig\u0026#39; local coq = require \u0026#34;coq\u0026#34; -- Use an on_attach function to only map the following keys -- after the language server attaches to the current buffer local on_attach = function(client, bufnr) local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end --Enable completion triggered by \u0026lt;c-x\u0026gt;\u0026lt;c-o\u0026gt; buf_set_option(\u0026#39;omnifunc\u0026#39;, \u0026#39;v:lua.vim.lsp.omnifunc\u0026#39;) -- Mappings. local opts = { noremap=true, silent=false } -- local opts = {} -- See `:help vim.lsp.*` for documentation on any of the below functions buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;gD\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.declaration()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;gd\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.definition()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.hover()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;gi\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.implementation()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;C-k\u0026gt;\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.signature_help()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;wa\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.add_workspace_folder()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;wr\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.remove_workspace_folder()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;wl\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;D\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.type_definition()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;rn\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.rename()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;ca\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.code_action()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;gr\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.references()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;e\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.diagnostic.show_line_diagnostics()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;[d\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.diagnostic.goto_prev()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;]d\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.diagnostic.goto_next()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;q\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.diagnostic.set_loclist()\u0026lt;CR\u0026gt;\u0026#39;, opts) buf_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;space\u0026gt;f\u0026#39;, \u0026#39;\u0026lt;cmd\u0026gt;lua vim.lsp.buf.formatting()\u0026lt;CR\u0026gt;\u0026#39;, opts) require \u0026#39;lsp_signature\u0026#39;.on_attach({ bind = true, zindex = 200, doc_lines = 0 }, bufnr) end -- Use a loop to conveniently call \u0026#39;setup\u0026#39; on multiple servers and -- map buffer local keybindings when the language server attaches nvim_lsp.gopls.setup( coq.lsp_ensure_capabilities({ on_attach = on_attach, cmd = {\u0026#34;gopls\u0026#34;}, settings = { analyses = { unusedparams = true, }, staticcheck = true, usePlaceholders = true, gofumpt = true, } }) ) function gofmt(timeout_ms) goimports(timeout_ms) vim.lsp.buf.formatting_sync() end function goimports(timeout_ms) local context = { only = { \u0026#34;source.organizeImports\u0026#34; } } vim.validate { context = { context, \u0026#34;t\u0026#34;, true } } local params = vim.lsp.util.make_range_params() params.context = context -- See the implementation of the textDocument/codeAction callback -- (lua/vim/lsp/handler.lua) for how to do this properly. local result = vim.lsp.buf_request_sync(0, \u0026#34;textDocument/codeAction\u0026#34;, params, timeout_ms) if not result or next(result) == nil then return end local actions = result[1].result if not actions then return end local action = actions[1] -- textDocument/codeAction can return either Command[] or CodeAction[]. If it -- is a CodeAction, it can have either an edit, a command or both. Edits -- should be executed first. if action.edit or type(action.command) == \u0026#34;table\u0026#34; then if action.edit then vim.lsp.util.apply_workspace_edit(action.edit) end if type(action.command) == \u0026#34;table\u0026#34; then vim.lsp.buf.execute_command(action.command) end else vim.lsp.buf.execute_command(action) end end Once you have all the files ready\nOpen neovim type :PlugInstall type :COQdeps Now, you should be ready for go development in neovim.\nCouple of shortcuts to get you started:\n\u0026lt;Ctrl\u0026gt; + n : Opens file browser \u0026lt;Space\u0026gt; + ff : Search for a file "},{"id":3,"href":"/post/hello/","title":"Hello","section":"Posts","content":"I used to blog not so frequently at https://experience-themaster.blogspot.com/ and that has stopped as I had little time to write about. This time I am trying to revive the habit of writing and making it more frequent. I am getting my hands dirty with emacs org mode which is what I am using to post this. I am hoping that one day, I might combine both blogs at one single place. More interesting content to follow.\n"}]